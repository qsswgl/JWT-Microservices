JWT配合API网关实现微服务架构API授权解决方案
原理和实现细节：
一、核心架构组件
1. JWT Token结构
JWT由三部分组成，用"."分隔：
Header.Payload.Signature
Header（头部）
json{
  "alg": "HS256",  // 签名算法
  "typ": "JWT"      // Token类型
}
Payload（载荷）
json{
  "sub": "user123",              // 用户ID
  "name": "张三",
  "roles": ["Admin", "User"],    // 角色
  "permissions": ["order:read", "order:write"],
  "iat": 1699000000,             // 签发时间
  "exp": 1699003600,             // 过期时间(1小时后)
  "jti": "unique-token-id"       // Token唯一标识
}
```

**Signature（签名）**
```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret_key
)
```

### 2. API网关的核心职责
```
┌─────────────────────────────────────────┐
│           API网关(Ocelot/YARP)          │
├─────────────────────────────────────────┤
│ 1. 请求接收与路由                        │
│ 2. JWT Token验证                        │
│ 3. 权限校验(基于角色/策略)               │
│ 4. 请求转发与负载均衡                    │
│ 5. 响应聚合                              │
│ 6. 限流熔断                              │
│ 7. 日志监控                              │
└─────────────────────────────────────────┘
二、详细工作流程
阶段1：用户认证与Token生成

客户端发起登录

用户输入用户名/密码
发送到API网关的 /auth/login 端点


网关转发到认证服务

网关不处理认证逻辑，只做转发
认证服务验证凭证（通常查询用户服务）


生成JWT Token

csharppublic class JwtTokenGenerator
{
    public TokenResponse GenerateToken(User user)
    {
        var claims = new[]
        {
            new Claim(JwtRegisteredClaimNames.Sub, user.Id),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
            new Claim(ClaimTypes.Name, user.Username),
            new Claim(ClaimTypes.Role, string.Join(",", user.Roles)),
            new Claim("permissions", JsonSerializer.Serialize(user.Permissions))
        };

        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_secretKey));
        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

        var accessToken = new JwtSecurityToken(
            issuer: "AuthService",
            audience: "ApiGateway",
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(30),  // 短期
            signingCredentials: credentials
        );

        var refreshToken = new JwtSecurityToken(
            issuer: "AuthService",
            audience: "ApiGateway",
            claims: new[] { new Claim(JwtRegisteredClaimNames.Sub, user.Id) },
            expires: DateTime.UtcNow.AddDays(7),  // 长期
            signingCredentials: credentials
        );

        return new TokenResponse
        {
            AccessToken = new JwtSecurityTokenHandler().WriteToken(accessToken),
            RefreshToken = new JwtSecurityTokenHandler().WriteToken(refreshToken),
            ExpiresIn = 1800 // 30分钟
        };
    }
}
阶段2：API网关验证与路由
当客户端携带Token访问API时，网关执行以下步骤：
步骤1：提取Token
csharp// 从HTTP Header中提取
var authHeader = context.Request.Headers["Authorization"].FirstOrDefault();
if (authHeader?.StartsWith("Bearer ") == true)
{
    var token = authHeader.Substring("Bearer ".Length).Trim();
}
步骤2：验证Token签名和有效性
csharppublic class TokenValidationMiddleware
{
    public async Task InvokeAsync(HttpContext context)
    {
        var token = ExtractToken(context);
        
        if (string.IsNullOrEmpty(token))
        {
            context.Response.StatusCode = 401;
            await context.Response.WriteAsync("Missing token");
            return;
        }

        try
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.UTF8.GetBytes(_configuration["Jwt:Key"]);
            
            // 验证Token
            var validationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = true,
                ValidIssuer = "AuthService",
                ValidateAudience = true,
                ValidAudience = "ApiGateway",
                ValidateLifetime = true,  // 验证过期时间
                ClockSkew = TimeSpan.Zero  // 不允许时间偏差
            };

            var principal = tokenHandler.ValidateToken(
                token, 
                validationParameters, 
                out SecurityToken validatedToken
            );

            // 将用户信息附加到请求上下文
            context.User = principal;
            
            // 可选：检查Token是否在黑名单中（已撤销）
            var jti = principal.FindFirst(JwtRegisteredClaimNames.Jti)?.Value;
            if (await _cache.ExistsAsync($"revoked_token:{jti}"))
            {
                context.Response.StatusCode = 401;
                await context.Response.WriteAsync("Token has been revoked");
                return;
            }

            await _next(context);
        }
        catch (SecurityTokenExpiredException)
        {
            context.Response.StatusCode = 401;
            await context.Response.WriteAsync("Token expired");
        }
        catch (Exception)
        {
            context.Response.StatusCode = 401;
            await context.Response.WriteAsync("Invalid token");
        }
    }
}
步骤3：权限检查
csharppublic class AuthorizationMiddleware
{
    public async Task InvokeAsync(HttpContext context)
    {
        var endpoint = context.GetEndpoint();
        var requiredRoles = endpoint?.Metadata
            .GetMetadata<RequiredRolesAttribute>()?.Roles;

        if (requiredRoles != null && requiredRoles.Any())
        {
            var userRoles = context.User.FindAll(ClaimTypes.Role)
                .Select(c => c.Value);

            if (!requiredRoles.Any(r => userRoles.Contains(r)))
            {
                context.Response.StatusCode = 403;
                await context.Response.WriteAsync("Insufficient permissions");
                return;
            }
        }

        await _next(context);
    }
}
步骤4：路由转发
使用Ocelot配置：
json{
  "Routes": [
    {
      "DownstreamPathTemplate": "/api/orders/{everything}",
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
        { "Host": "order-service", "Port": 80 }
      ],
      "UpstreamPathTemplate": "/api/orders/{everything}",
      "UpstreamHttpMethod": [ "Get", "Post", "Put", "Delete" ],
      "AuthenticationOptions": {
        "AuthenticationProviderKey": "Bearer",
        "AllowedScopes": []
      },
      "RouteClaimsRequirement": {
        "Role": "Admin,User"
      },
      "AddHeadersToRequest": {
        "X-User-Id": "Claims[sub] > value",
        "X-User-Roles": "Claims[role] > value"
      },
      "RateLimitOptions": {
        "ClientWhitelist": [],
        "EnableRateLimiting": true,
        "Period": "1m",
        "PeriodTimespan": 60,
        "Limit": 100
      }
    }
  ]
}
阶段3：下游服务处理
网关转发请求到后端微服务时，会添加额外的Header：
httpGET /api/orders/123 HTTP/1.1
Host: order-service
Authorization: Bearer eyJhbGc...  (原始Token)
X-User-Id: user123                (从Token解析)
X-User-Roles: Admin,User          (从Token解析)
X-Request-Id: abc-def-ghi         (追踪ID)
后端服务可以直接使用这些Header，无需再次验证Token：
csharp[ApiController]
[Route("api/[controller]")]
public class OrdersController : ControllerBase
{
    [HttpGet("{id}")]
    public IActionResult GetOrder(int id)
    {
        // 从Header获取用户信息（已被网关验证）
        var userId = Request.Headers["X-User-Id"].ToString();
        var roles = Request.Headers["X-User-Roles"].ToString().Split(',');
        
        // 业务逻辑...
        return Ok(order);
    }
}
三、关键技术要点
1. Token存储策略
客户端存储
javascript// 浏览器端
// 方式1：localStorage (XSS风险)
localStorage.setItem('access_token', token);

// 方式2：HttpOnly Cookie (推荐，防XSS)
// 服务端设置Cookie
response.Cookies.Append("access_token", token, new CookieOptions
{
    HttpOnly = true,
    Secure = true,
    SameSite = SameSiteMode.Strict,
    Expires = DateTime.UtcNow.AddMinutes(30)
});

// 方式3：内存存储 (最安全但刷新丢失)
let tokenInMemory = token;
2. Token刷新机制
csharp[HttpPost("refresh")]
public async Task<IActionResult> RefreshToken([FromBody] RefreshTokenRequest request)
{
    try
    {
        // 验证Refresh Token
        var principal = ValidateRefreshToken(request.RefreshToken);
        var userId = principal.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        
        // 查询用户最新信息
        var user = await _userService.GetUserAsync(userId);
        
        // 生成新的Access Token
        var newAccessToken = GenerateAccessToken(user);
        
        return Ok(new { AccessToken = newAccessToken });
    }
    catch
    {
        return Unauthorized("Invalid refresh token");
    }
}
3. Token撤销机制
csharp// 登出时撤销Token
[HttpPost("logout")]
public async Task<IActionResult> Logout()
{
    var jti = User.FindFirst(JwtRegisteredClaimNames.Jti)?.Value;
    var exp = User.FindFirst(JwtRegisteredClaimNames.Exp)?.Value;
    
    if (!string.IsNullOrEmpty(jti) && !string.IsNullOrEmpty(exp))
    {
        var expireTime = DateTimeOffset.FromUnixTimeSeconds(long.Parse(exp));
        var ttl = expireTime - DateTimeOffset.UtcNow;
        
        // 将Token加入黑名单，直到其自然过期
        await _cache.SetAsync(
            $"revoked_token:{jti}", 
            "revoked", 
            ttl
        );
    }
    
    return Ok();
}
四、安全最佳实践

使用强签名算法：HS256或RS256
短期Access Token：15-30分钟
长期Refresh Token：7-30天
HTTPS强制：所有通信必须加密
Token轮换：每次刷新都生成新的Refresh Token
限流保护：防止暴力破解
敏感数据不放Payload：JWT是Base64编码，不是加密
使用JTI防重放：记录已使用的Token ID

五、性能优化

Redis缓存Token验证结果

csharpvar cacheKey = $"token_validated:{tokenHash}";
var cached = await _cache.GetAsync(cacheKey);
if (cached != null) 
{
    // 使用缓存的验证结果
}

网关层解析Claims：避免下游服务重复解析
使用非对称加密(RS256)：公钥分发到各服务，提高验证性能

这套方案的优势在于：

无状态：不需要服务器存储Session
可扩展：微服务独立部署
性能好：网关验证一次，下游服务信任网关
安全性高：集中式验证和权限管理